#!/bin/sh
# Enhanced editor wrapper for git-aware file opening

set -e

show_help() {
	cat <<EOF
Usage: e [OPTIONS] [FILES...]

Enhanced editor wrapper for git-aware file opening.

OPTIONS:
    -m, --modified           Open modified git files
    -u, --untracked          Open untracked git files (can be combined with -m)
    -g, --grep PATTERN       Open files matching pattern (uses git grep in git repos, grep otherwise)
    -n, --name PATTERN       Open files whose names match pattern (e.g., "*.py")
    -d, --diff [REF]         Open files from git diff (compares to default branch or REF)
    -a, --all                Open all files in git repo (tracked files)
    --history [N]            Open N most recently modified files (default: 10)
    -i, --interactive        Use fzf to select files interactively
    -h, --help               Show this help message

EXAMPLES:
    e                        Open editor with no files
    e file.txt               Open file.txt
    e -m                     Open all modified files
    e -u                     Open all untracked files
    e -mu                    Open all modified and untracked files
    e -mui                   Select from modified/untracked files with fzf
    e -g "TODO"              Open files containing "TODO"
    e -n "*.py"              Open files whose names match *.py
    e -d                     Open files changed from default branch
    e -d dev                 Open files changed from dev branch
    e -a                     Open all tracked files in git repo
    e -ai                    Select from all tracked files with fzf
    e --history              Open 10 most recently modified files
    e --history 20           Open 20 most recently modified files

PIPING:
    find . -name "*.py" | e  Open all Python files
    git ls-files | e         Open all tracked files
    ls | e -i                Pipe files to fzf for selection

EDITOR: Uses \$EDITOR (currently: ${EDITOR:-vi})
EOF
}

die() {
	echo "Error: $1" >&2
	exit 1
}

# Detect default branch
get_default_branch() {
	# Try to get the default branch from origin/HEAD
	local default_branch
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

	if [ -n "$default_branch" ]; then
		echo "$default_branch"
		return
	fi

	# Fallback: check if main or master exists
	if git show-ref --verify --quiet refs/heads/main; then
		echo "main"
	elif git show-ref --verify --quiet refs/heads/master; then
		echo "master"
	else
		# Last resort: use current branch
		git branch --show-current
	fi
}

# Check if we're in a git repo once at startup
is_git_repo=false
git_root=""
if git rev-parse --git-dir >/dev/null 2>&1; then
	is_git_repo=true
	git_root=$(git rev-parse --show-toplevel)
fi

# Check if in a git repo (for git-related operations)
check_git_repo() {
	if [ "$is_git_repo" = false ]; then
		die "Not in a git repository"
	fi
}

# Convert git-relative paths to paths relative to current directory
make_paths_relative() {
	local git_files="$1"
	if [ -z "$git_root" ] || [ "$git_root" = "$PWD" ]; then
		# Already at git root or not in git repo
		echo "$git_files"
	else
		# Prefix each path with git_root
		echo "$git_files" | while IFS= read -r file; do
			[ -n "$file" ] && echo "$git_root/$file"
		done
	fi
}

# Parse arguments
mode=""
pattern=""
diff_ref=""
history_count=10
use_fzf=false
include_untracked=false
files=()

while [ $# -gt 0 ]; do
	case "$1" in
		-h|--help)
			show_help
			exit 0
			;;
		-m|--modified)
			mode="modified"
			shift
			;;
		-u|--untracked)
			include_untracked=true
			shift
			;;
		-g|--grep)
			mode="grep"
			shift
			if [ $# -eq 0 ]; then
				die "Option -g/--grep requires a pattern"
			fi
			pattern="$1"
			shift
			;;
		-n|--name)
			mode="name"
			shift
			if [ $# -eq 0 ]; then
				die "Option -n/--name requires a pattern"
			fi
			pattern="$1"
			shift
			;;
		-a|--all)
			mode="all"
			shift
			;;
		--history)
			mode="history"
			shift
			# Check if next arg is a number (not a flag)
			if [ $# -gt 0 ] && [ "${1#-}" = "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
				history_count="$1"
				shift
			fi
			;;
		-d|--diff)
			mode="diff"
			shift
			# Check if next arg is a ref (not a flag)
			if [ $# -gt 0 ] && [ "${1#-}" = "$1" ]; then
				diff_ref="$1"
				shift
			fi
			;;
		-i|--interactive)
			use_fzf=true
			shift
			;;
		-*)
			# Handle combined short flags (e.g., -mu, -mi)
			if [ "${#1}" -gt 2 ] && [ "${1#--}" = "$1" ]; then
				# Extract individual flags
				flags="${1#-}"
				shift
				# Process each character as a separate flag
				while [ -n "$flags" ]; do
					flag="${flags%"${flags#?}"}"
					flags="${flags#?}"
					case "$flag" in
						m) mode="modified" ;;
						u) include_untracked=true ;;
						i) use_fzf=true ;;
						a) mode="all" ;;
						g|d|n|h)
							die "Option -$flag cannot be combined with other flags"
							;;
						*)
							die "Unknown option: -$flag"
							;;
					esac
				done
			else
				die "Unknown option: $1"
			fi
			;;
		*)
			files="$files $1"
			shift
			;;
	esac
done

# Check for stdin input (piped data)
has_stdin=false
if [ ! -t 0 ]; then
	has_stdin=true
	stdin_files=$(cat)

	# Error if trying to use stdin with mode flags
	if [ -n "$mode" ]; then
		die "Cannot use stdin input with mode flags (-m, -u, -g, -d)"
	fi

	files="$files $stdin_files"
fi

# Get list of files based on mode
file_list=""

# Handle the case where -u is used alone (no mode set)
if [ "$include_untracked" = true ] && [ -z "$mode" ]; then
	mode="untracked"
fi

case "$mode" in
	modified)
		check_git_repo
		if [ "$include_untracked" = true ]; then
			file_list=$(git status --porcelain | awk '{print $2}')
		else
			file_list=$(git status --porcelain | grep '^ M\| M\|^M' | awk '{print $2}')
		fi
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No modified files found"
		fi
		;;
	untracked)
		check_git_repo
		file_list=$(git status --porcelain | grep '^??' | awk '{print $2}')
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No untracked files found"
		fi
		;;
	grep)
		# Use git grep if in a git repo, otherwise use regular grep
		if [ "$is_git_repo" = true ]; then
			file_list=$(git grep -l "$pattern" 2>/dev/null || true)
			file_list=$(make_paths_relative "$file_list")
		else
			# Recursive grep, exclude common directories, only list filenames
			file_list=$(grep -r -l "$pattern" . 2>/dev/null | grep -v '/\.' | sed 's|^\./||' || true)
		fi
		if [ -z "$file_list" ]; then
			die "No files matching pattern '$pattern'"
		fi
		;;
	name)
		# Find files by name pattern
		if [ "$is_git_repo" = true ]; then
			# In git repo, search tracked files
			file_list=$(git ls-files | grep "$pattern" || true)
			file_list=$(make_paths_relative "$file_list")
		else
			# Outside git repo, use find
			file_list=$(find . -type f -name "$pattern" 2>/dev/null | sed 's|^\./||' || true)
		fi
		if [ -z "$file_list" ]; then
			die "No files matching name pattern '$pattern'"
		fi
		;;
	all)
		check_git_repo
		file_list=$(git ls-files)
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No tracked files found"
		fi
		;;
	history)
		# Get N most recently modified files by filesystem modification time
		if [ "$is_git_repo" = true ]; then
			# In git repo, only consider tracked files
			# Use stat to get mtime, sort by it, take top N
			# Need to run stat from git root since git ls-files returns paths relative to root
			file_list=$(cd "$git_root" && git ls-files -z | xargs -0 stat -f "%m %N" 2>/dev/null | sort -rn | head -n "$history_count" | cut -d' ' -f2-)
			file_list=$(make_paths_relative "$file_list")
		else
			# Outside git repo, find all files and sort by mtime
			# -printf '%T@ %p\n' prints: modification_time_in_seconds filepath
			# %T@ = file's last modification time in seconds since Unix epoch (with decimal fractions)
			# %p = file's path
			# \n = newline
			# We sort numerically in reverse (-rn), take top N, then strip the timestamp
			file_list=$(find . -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -n "$history_count" | cut -d' ' -f2- | sed 's|^\./||')
		fi
		if [ -z "$file_list" ]; then
			die "No files found"
		fi
		;;
	diff)
		check_git_repo
		if [ -z "$diff_ref" ]; then
			diff_ref=$(get_default_branch)
		fi
		file_list=$(git diff --name-only "$diff_ref"..HEAD 2>/dev/null || true)
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No files changed from $diff_ref"
		fi
		;;
	"")
		# No mode, use provided files (or open editor with no args)
		file_list="$files"
		;;
esac

# Use fzf for interactive selection if requested
if [ "$use_fzf" = true ]; then
	if ! command -v fzf >/dev/null 2>&1; then
		die "fzf is not installed"
	fi
	file_list=$(echo "$file_list" | fzf --multi)
	if [ -z "$file_list" ]; then
		echo "No files selected"
		exit 0
	fi
fi

# Open files in editor
editor="${EDITOR:-vi}"

# Convert file_list to proper arguments (handle spaces in filenames)
exec $editor $file_list
