#!/bin/bash
# Enhanced editor wrapper for git-aware file opening

set -e

show_help() {
	cat <<EOF
Usage: e [OPTIONS] [FILTERS...]

Enhanced editor wrapper for git-aware file opening with composable filters.

FILE SET OPTIONS (combinable: -m, -u, -a):
    -m, --modified           Modified tracked files
    -u, --untracked          Untracked files
    -a, --all                All tracked files (-a includes -m; -au = everything)
    -d, --diff [REF]         Files from git diff (default branch or REF)
    --history [N]            N most recently modified files (default: 10)

FILTER OPTIONS (can combine multiple):
    -g, --grep PATTERN       Filter by content matching PATTERN
    -n, --name PATTERN       Filter by filename matching PATTERN (regex)
    FILTERS...               Filter by filename substring (when using other options)

MODIFIERS:
    -i, --interactive        Use fzf to select files (implies -a if no file set)
    -h, --help               Show this help message

COMPOSITION: All filters AND together. For example:
    e -m -g TODO             Modified files containing "TODO"
    e -u -n test             Untracked files with "test" in name
    e -g TODO test           Files containing "TODO" with "test" in filename
    e -m -g TODO -n .py      Modified Python files containing "TODO"
    e -a component           All tracked files with "component" in filename
    e -mui                   Modified+untracked files, interactive selection

BASIC USAGE:
    e                        Open editor with no files
    e file.txt               Open file.txt (create if doesn't exist)
    e -m                     Open all modified files
    e -mu                    Open modified and untracked files
    e -d                     Open files changed from default branch
    e -d dev                 Open files changed from dev branch
    e -i                     Browse all tracked files with fzf
    e -i foo                 Browse files matching "foo" with fzf
    e --history              Open 10 most recently modified files

PIPING:
    find . -name "*.py" | e  Open all Python files
    git ls-files | e         Open all tracked files
    ls | e -i                Pipe files to fzf for selection

EDITOR: Uses \$EDITOR (currently: ${EDITOR:-vi})
EOF
}

die() {
	echo "Error: $1" >&2
	exit 1
}

# Detect default branch
get_default_branch() {
	# Try to get the default branch from origin/HEAD
	local default_branch
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

	if [ -n "$default_branch" ]; then
		echo "$default_branch"
		return
	fi

	# Fallback: check if main or master exists
	if git show-ref --verify --quiet refs/heads/main; then
		echo "main"
	elif git show-ref --verify --quiet refs/heads/master; then
		echo "master"
	else
		# Last resort: use current branch
		git branch --show-current
	fi
}

# Check if we're in a git repo once at startup
is_git_repo=false
git_root=""
if git rev-parse --git-dir >/dev/null 2>&1; then
	is_git_repo=true
	git_root=$(git rev-parse --show-toplevel)
fi

# Check if in a git repo (for git-related operations)
check_git_repo() {
	if [ "$is_git_repo" = false ]; then
		die "Not in a git repository"
	fi
}

# Convert git-relative paths to paths relative to current directory
make_paths_relative() {
	local git_files="$1"
	if [ -z "$git_root" ] || [ "$git_root" = "$PWD" ]; then
		# Already at git root or not in git repo
		echo "$git_files"
	else
		# Prefix each path with git_root
		echo "$git_files" | while IFS= read -r file; do
			[ -n "$file" ] && echo "$git_root/$file"
		done
	fi
}

# Parse arguments
file_set=""
grep_pattern=""
name_pattern=""
diff_ref=""
history_count=10
use_fzf=false
include_untracked=false
positional_filters=""

while [ $# -gt 0 ]; do
	case "$1" in
		-h|--help)
			show_help
			exit 0
			;;
		-m|--modified)
			# -a is superset of -m, so if -a is set, ignore -m
			if [ "$file_set" != "all" ]; then
				file_set="modified"
			fi
			shift
			;;
		-u|--untracked)
			include_untracked=true
			shift
			;;
		-g|--grep)
			shift
			if [ $# -eq 0 ]; then
				die "Option -g/--grep requires a pattern"
			fi
			grep_pattern="$1"
			shift
			;;
		-n|--name)
			shift
			if [ $# -eq 0 ]; then
				die "Option -n/--name requires a pattern"
			fi
			name_pattern="$1"
			shift
			;;
		-a|--all)
			# -a is superset of -m, so -a always wins
			if [ -n "$file_set" ] && [ "$file_set" != "modified" ]; then
				die "Cannot combine -a with -d or --history"
			fi
			file_set="all"
			shift
			;;
		--history)
			if [ -n "$file_set" ]; then
				die "Cannot combine multiple file set options"
			fi
			file_set="history"
			shift
			# Check if next arg is a number (not a flag)
			if [ $# -gt 0 ] && [ "${1#-}" = "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
				history_count="$1"
				shift
			fi
			;;
		-d|--diff)
			if [ -n "$file_set" ]; then
				die "Cannot combine multiple file set options"
			fi
			file_set="diff"
			shift
			# Check if next arg is a ref (not a flag)
			if [ $# -gt 0 ] && [ "${1#-}" = "$1" ]; then
				diff_ref="$1"
				shift
			fi
			;;
		-i|--interactive)
			use_fzf=true
			shift
			;;
		-*)
			# Handle combined short flags (e.g., -mu, -mi)
			if [ "${#1}" -gt 2 ] && [ "${1#--}" = "$1" ]; then
				# Extract individual flags
				flags="${1#-}"
				shift
				# Process each character as a separate flag
				while [ -n "$flags" ]; do
					flag="${flags%"${flags#?}"}"
					flags="${flags#?}"
					case "$flag" in
						m)
							# -a is superset of -m, so if -a is set, ignore -m
							if [ "$file_set" != "all" ]; then
								file_set="modified"
							fi
							;;
						u) include_untracked=true ;;
						i) use_fzf=true ;;
						a)
							# -a is superset of -m, so -a always wins
							if [ -n "$file_set" ] && [ "$file_set" != "modified" ]; then
								die "Cannot combine -a with -d or --history"
							fi
							file_set="all"
							;;
						g|d|n|h)
							die "Option -$flag cannot be combined with other flags (requires argument)"
							;;
						*)
							die "Unknown option: -$flag"
							;;
					esac
				done
			else
				die "Unknown option: $1"
			fi
			;;
		*)
			# Collect positional argument (only one allowed with filters, multiple for direct file opening)
			if [ -n "$positional_filters" ]; then
				positional_filters="$positional_filters $1"
			else
				positional_filters="$1"
			fi
			shift
			;;
	esac
done

# Validate: if using filters, only one positional arg allowed
if [ -n "$file_set" -o -n "$grep_pattern" -o -n "$name_pattern" ]; then
	# Count words in positional_filters
	word_count=$(echo "$positional_filters" | wc -w | tr -d ' ')
	if [ "$word_count" -gt 1 ]; then
		die "Only one positional filter allowed. Use regex for complex patterns (e.g., 'test.*component')"
	fi
fi

# Check for stdin input (piped data)
# Use timeout to check if stdin has data without blocking
has_stdin=false
if [ ! -t 0 ]; then
	# Try to read stdin with 0.01s timeout - if data available, read it all
	stdin_files=$(timeout 0.01 cat 2>/dev/null || true)

	if [ -n "$stdin_files" ]; then
		has_stdin=true

		# Error if trying to use stdin with file set or filter flags
		if [ -n "$file_set" ] || [ -n "$grep_pattern" ] || [ -n "$name_pattern" ]; then
			die "Cannot use stdin input with file set or filter flags"
		fi

		positional_filters="$positional_filters $stdin_files"
	fi
fi

# Build file list using composable filters
file_list=""

# Step 1: Determine base file set
# Handle the case where -u is used alone (no file_set)
if [ "$include_untracked" = true ] && [ -z "$file_set" ]; then
	file_set="untracked"
fi

case "$file_set" in
	modified)
		check_git_repo
		if [ "$include_untracked" = true ]; then
			# Get modified and untracked, but exclude deleted files
			file_list=$(git status --porcelain | grep -v '^D\| D' | awk '{print $2}')
		else
			# Get only modified files (not deleted)
			file_list=$(git status --porcelain | grep '^ M\| M\|^M' | grep -v '^D\| D' | awk '{print $2}')
		fi
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No modified files found"
		fi
		;;
	untracked)
		check_git_repo
		file_list=$(git ls-files --others --exclude-standard --full-name)
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No untracked files found"
		fi
		;;
	all)
		check_git_repo
		file_list=$(git ls-files --full-name)
		if [ "$include_untracked" = true ]; then
			untracked=$(git ls-files --others --exclude-standard --full-name)
			file_list="$file_list"$'\n'"$untracked"
		fi
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No files found"
		fi
		;;
	history)
		# Get N most recently modified files by filesystem modification time
		if [ "$is_git_repo" = true ]; then
			# In git repo, only consider tracked files
			# Use stat to get mtime, sort by it, take top N
			# Need to run stat from git root since git ls-files returns paths relative to root
			file_list=$(cd "$git_root" && git ls-files -z | xargs -0 stat -f "%m %N" 2>/dev/null | sort -rn | head -n "$history_count" | cut -d' ' -f2-)
			file_list=$(make_paths_relative "$file_list")
		else
			# Outside git repo, find all files and sort by mtime
			# -printf '%T@ %p\n' prints: modification_time_in_seconds filepath
			# %T@ = file's last modification time in seconds since Unix epoch (with decimal fractions)
			# %p = file's path
			# \n = newline
			# We sort numerically in reverse (-rn), take top N, then strip the timestamp
			file_list=$(find . -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -n "$history_count" | cut -d' ' -f2- | sed 's|^\./||')
		fi
		if [ -z "$file_list" ]; then
			die "No files found"
		fi
		;;
	diff)
		check_git_repo
		if [ -z "$diff_ref" ]; then
			diff_ref=$(get_default_branch)
		fi
		file_list=$(git diff --name-only "$diff_ref"..HEAD 2>/dev/null || true)
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No files changed from $diff_ref"
		fi
		;;
	"")
		# No file set specified
		# If we have filters or interactive mode, default to all tracked files (or all files if not in git repo)
		if [ -n "$grep_pattern" ] || [ -n "$name_pattern" ] || [ "$use_fzf" = true ]; then
			if [ "$is_git_repo" = true ]; then
				file_list=$(git ls-files --full-name)
				file_list=$(make_paths_relative "$file_list")
			else
				# Outside git repo, find all files
				file_list=$(find . -type f 2>/dev/null | sed 's|^\./||' || true)
			fi
		else
			# No file set and no filters - use positional args as files to open
			file_list="$positional_filters"
		fi
		;;
esac

# Step 2: Apply all filename filters (cheap - do this before expensive grep)
# Both -n and positional arg are just filename pattern matching
if [ -n "$file_list" ]; then
	# Apply -n pattern if provided
	if [ -n "$name_pattern" ]; then
		file_list=$(echo "$file_list" | grep "$name_pattern" || true)
		if [ -z "$file_list" ]; then
			die "No files matching name pattern '$name_pattern'"
		fi
	fi

	# Apply positional filter if provided (only when using filters, not for direct file opening)
	if [ -n "$positional_filters" ] && [ -n "$file_set" -o -n "$grep_pattern" -o -n "$name_pattern" -o "$use_fzf" = true ]; then
		file_list=$(echo "$file_list" | grep "$positional_filters" || true)
		if [ -z "$file_list" ]; then
			die "No files matching filter '$positional_filters'"
		fi
	fi
fi

# Step 3: Apply content filter (expensive - do this last on the reduced file set)
if [ -n "$grep_pattern" ] && [ -n "$file_list" ]; then
	if [ "$is_git_repo" = true ]; then
		# Use git grep on the file list
		filtered=""
		for file in $file_list; do
			if git grep -q "$grep_pattern" -- "$file" 2>/dev/null; then
				filtered="$filtered$file"$'\n'
			fi
		done
		file_list="$filtered"
	else
		# Use regular grep
		filtered=""
		for file in $file_list; do
			if [ -f "$file" ] && grep -q "$grep_pattern" "$file" 2>/dev/null; then
				filtered="$filtered$file"$'\n'
			fi
		done
		file_list="$filtered"
	fi

	if [ -z "$file_list" ]; then
		die "No files matching content pattern '$grep_pattern'"
	fi
fi

# Use fzf for interactive selection if requested
if [ "$use_fzf" = true ]; then
	if ! command -v fzf >/dev/null 2>&1; then
		die "fzf is not installed"
	fi
	file_list=$(echo "$file_list" | fzf --multi)
	if [ -z "$file_list" ]; then
		echo "No files selected"
		exit 0
	fi
fi

# Open files in editor
editor="${EDITOR:-vi}"

# Convert file_list to proper arguments (handle spaces in filenames)
exec $editor $file_list
