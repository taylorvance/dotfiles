#!/bin/bash
# Enhanced editor wrapper for git-aware file opening

set -e

show_help() {
	cat <<EOF
Usage: e [OPTIONS] [FILTERS...]

Enhanced editor wrapper for git-aware file opening with composable filters.

FILE SET OPTIONS (combinable: -m, -u, -a):
    -m, --modified           Modified tracked files
    -u, --untracked          Untracked files
    -a, --all                All tracked files (-a includes -m; -au = everything)
    -d, --diff [ARG]         Files from git diff (passes ARG to git diff --name-only)
    -r, --recent [N]         N most recently modified files (default: 10)

FILTER OPTIONS (can combine multiple):
    -g, --grep PATTERN       Filter by content matching PATTERN
    -n, --name PATTERN       Filter by filename matching PATTERN (regex)
    FILTERS...               Filter by filename substring (when using other options)

MODIFIERS:
    -i, --interactive        Use fzf to select files (implies -a if no file set)
    -h, --help               Show this help message

COMPOSITION: All filters AND together. For example:
    e -m -g TODO             Modified files containing "TODO"
    e -u -n test             Untracked files with "test" in name
    e -g TODO test           Files containing "TODO" with "test" in filename
    e -m -g TODO -n .py      Modified Python files containing "TODO"
    e -a component           All tracked files with "component" in filename
    e -mui                   Modified+untracked files, interactive selection

BASIC USAGE:
    e                        Open editor with no files
    e file.txt               Open file.txt (create if doesn't exist)
    e -m                     Open all modified files
    e -mu                    Open modified and untracked files
    e -d                     Open files differing from default branch
    e -d dev                 Open files differing from dev branch
    e -d main..HEAD          Open files changed between main and HEAD
    e -d branch1..branch2    Open files changed between two branches
    e -i                     Browse all tracked files with fzf
    e -i foo                 Browse files matching "foo" with fzf
    e -r                     Open 10 most recently modified files

PIPING:
    find . -name "*.py" | e  Open all Python files
    git ls-files | e         Open all tracked files
    ls | e -i                Pipe files to fzf for selection

EDITOR: Uses \$EDITOR (currently: ${EDITOR:-vi})
EOF
}

die() {
	echo "Error: $1" >&2
	exit 1
}

# Detect default branch
get_default_branch() {
	# Try to get the default branch from origin/HEAD
	local default_branch
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

	if [ -n "$default_branch" ]; then
		echo "$default_branch"
		return
	fi

	# Fallback: check if main or master exists
	if git show-ref --verify --quiet refs/heads/main; then
		echo "main"
	elif git show-ref --verify --quiet refs/heads/master; then
		echo "master"
	else
		# Last resort: use current branch
		git branch --show-current
	fi
}

# Check if we're in a git repo once at startup
is_git_repo=false
git_root=""
if git rev-parse --git-dir >/dev/null 2>&1; then
	is_git_repo=true
	git_root=$(git rev-parse --show-toplevel)
fi

# Check if in a git repo (for git-related operations)
check_git_repo() {
	if [ "$is_git_repo" = false ]; then
		die "Not in a git repository"
	fi
}

# Convert git-relative paths to paths relative to current directory
make_paths_relative() {
	local git_files="$1"
	if [ -z "$git_root" ] || [ "$git_root" = "$PWD" ]; then
		# Already at git root or not in git repo
		echo "$git_files"
	else
		# Prefix each path with git_root
		echo "$git_files" | while IFS= read -r file; do
			[ -n "$file" ] && echo "$git_root/$file"
		done
	fi
}

# Parse arguments
file_set=""
grep_pattern=""
name_pattern=""
diff_ref=""
recent_count=10
use_fzf=false
include_untracked=false
positional_args=()  # Array to properly handle files with spaces and globs

while [ $# -gt 0 ]; do
	case "$1" in
		-h|--help)
			show_help
			exit 0
			;;
		-m|--modified)
			# -a is superset of -m, so if -a is set, ignore -m
			if [ "$file_set" != "all" ]; then
				file_set="modified"
			fi
			shift
			;;
		-u|--untracked)
			include_untracked=true
			shift
			;;
		-g|--grep)
			shift
			if [ $# -eq 0 ]; then
				die "Option -g/--grep requires a pattern"
			fi
			grep_pattern="$1"
			shift
			;;
		-n|--name)
			shift
			if [ $# -eq 0 ]; then
				die "Option -n/--name requires a pattern"
			fi
			name_pattern="$1"
			shift
			;;
		-a|--all)
			# -a is superset of -m, so -a always wins
			if [ -n "$file_set" ] && [ "$file_set" != "modified" ]; then
				die "Cannot combine -a with -d or -r"
			fi
			file_set="all"
			shift
			;;
		-r|--recent)
			if [ -n "$file_set" ]; then
				die "Cannot combine multiple file set options"
			fi
			file_set="recent"
			shift
			# Check if next arg is a number (not a flag)
			if [ $# -gt 0 ] && [ "${1#-}" = "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
				recent_count="$1"
				shift
			fi
			;;
		-d|--diff)
			if [ -n "$file_set" ]; then
				die "Cannot combine multiple file set options"
			fi
			file_set="diff"
			shift
			# Check if next arg is a ref (not a flag)
			if [ $# -gt 0 ] && [ "${1#-}" = "$1" ]; then
				diff_ref="$1"
				shift
			fi
			;;
		-i|--interactive)
			use_fzf=true
			shift
			;;
		-*)
			# Handle combined short flags (e.g., -mu, -mi)
			if [ "${#1}" -gt 2 ] && [ "${1#--}" = "$1" ]; then
				# Extract individual flags
				flags="${1#-}"
				shift
				# Process each character as a separate flag
				while [ -n "$flags" ]; do
					flag="${flags%"${flags#?}"}"
					flags="${flags#?}"
					case "$flag" in
						m)
							# -a is superset of -m, so if -a is set, ignore -m
							if [ "$file_set" != "all" ]; then
								file_set="modified"
							fi
							;;
						u) include_untracked=true ;;
						i) use_fzf=true ;;
						a)
							# -a is superset of -m, so -a always wins
							if [ -n "$file_set" ] && [ "$file_set" != "modified" ]; then
								die "Cannot combine -a with -d or -r"
							fi
							file_set="all"
							;;
						g|d|n|h|r)
							die "Option -$flag cannot be combined with other flags (requires argument)"
							;;
						*)
							die "Unknown option: -$flag"
							;;
					esac
				done
			else
				die "Unknown option: $1"
			fi
			;;
		*)
			# Collect positional arguments (multiple allowed for direct file opening)
			positional_args+=("$1")
			shift
			;;
	esac
done

# Validate: if using filters, only one positional arg allowed
if [ -n "$file_set" ] || [ -n "$grep_pattern" ] || [ -n "$name_pattern" ]; then
	if [ "${#positional_args[@]}" -gt 1 ]; then
		die "Only one positional filter allowed when using flags. Use regex for complex patterns (e.g., 'test.*component')"
	fi
fi

# Convert array to newline-separated string for filter mode, or keep as array for direct mode
positional_filter=""
if [ "${#positional_args[@]}" -eq 1 ]; then
	positional_filter="${positional_args[0]}"
fi

# Check for stdin input (piped data)
# When stdin is not a terminal (piped/redirected), read all available data
stdin_files=""
if [ ! -t 0 ]; then
	stdin_files=$(cat)

	if [ -n "$stdin_files" ]; then
		# Error if trying to use stdin with file set or filter flags (except -i for interactive)
		if [ -n "$file_set" ] || [ -n "$grep_pattern" ] || [ -n "$name_pattern" ]; then
			die "Cannot use stdin input with file set or filter flags"
		fi

		# Error if positional args were also provided
		if [ "${#positional_args[@]}" -gt 0 ]; then
			die "Cannot use stdin input with positional arguments"
		fi
	fi
fi

# Build file list using composable filters
file_list=""

# Step 1: Determine base file set
# Handle the case where -u is used alone (no file_set)
if [ "$include_untracked" = true ] && [ -z "$file_set" ]; then
	file_set="untracked"
fi

case "$file_set" in
	modified)
		check_git_repo
		if [ "$include_untracked" = true ]; then
			# Get modified and untracked, but exclude deleted files
			# Use cut -c4- to handle filenames with spaces (skip status codes)
			file_list=$(git status --porcelain | grep -v '^D\| D' | cut -c4-)
		else
			# Get only modified files (not deleted)
			file_list=$(git status --porcelain | grep '^ M\| M\|^M' | grep -v '^D\| D' | cut -c4-)
		fi
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No modified files found"
		fi
		;;
	untracked)
		check_git_repo
		file_list=$(git ls-files --others --exclude-standard --full-name)
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No untracked files found"
		fi
		;;
	all)
		check_git_repo
		file_list=$(git ls-files --full-name)
		if [ "$include_untracked" = true ]; then
			untracked=$(git ls-files --others --exclude-standard --full-name)
			file_list="$file_list"$'\n'"$untracked"
		fi
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No files found"
		fi
		;;
	recent)
		# Get N most recently modified files by filesystem modification time
		# Detect OS for stat format (macOS vs Linux)
		if [[ "$OSTYPE" == "darwin"* ]]; then
			stat_cmd="stat -f %m"
		else
			stat_cmd="stat -c %Y"
		fi

		if [ "$is_git_repo" = true ]; then
			# In git repo, only consider tracked files
			# Use stat to get mtime, sort by it, take top N
			# Need to run stat from git root since git ls-files returns paths relative to root
			file_list=$(cd "$git_root" && git ls-files | while IFS= read -r f; do
				if [ -f "$f" ]; then
					mtime=$($stat_cmd "$f" 2>/dev/null) && echo "$mtime $f"
				fi
			done | sort -rn | head -n "$recent_count" | cut -d' ' -f2-)
			file_list=$(make_paths_relative "$file_list")
		else
			# Outside git repo, find all files and sort by mtime
			if [[ "$OSTYPE" == "darwin"* ]]; then
				# macOS: use stat
				file_list=$(find . -type f | while IFS= read -r f; do
					mtime=$($stat_cmd "$f" 2>/dev/null) && echo "$mtime $f"
				done | sort -rn | head -n "$recent_count" | cut -d' ' -f2- | sed 's|^\./||')
			else
				# Linux: find -printf is faster
				file_list=$(find . -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -n "$recent_count" | cut -d' ' -f2- | sed 's|^\./||')
			fi
		fi
		if [ -z "$file_list" ]; then
			die "No files found"
		fi
		;;
	diff)
		check_git_repo
		if [ -z "$diff_ref" ]; then
			diff_ref=$(get_default_branch)
		fi
		# Pass through to git diff directly
		file_list=$(git diff --name-only $diff_ref 2>/dev/null || true)
		file_list=$(make_paths_relative "$file_list")
		if [ -z "$file_list" ]; then
			die "No files changed for: git diff --name-only $diff_ref"
		fi
		;;
	"")
		# No file set specified
		if [ -n "$stdin_files" ]; then
			# Use stdin input (already newline-separated)
			file_list="$stdin_files"
		elif [ -n "$grep_pattern" ] || [ -n "$name_pattern" ] || [ "$use_fzf" = true ]; then
			# Have filters or interactive mode - default to all tracked files (or all files if not in git repo)
			if [ "$is_git_repo" = true ]; then
				file_list=$(git ls-files --full-name)
				file_list=$(make_paths_relative "$file_list")
			else
				# Outside git repo, find all files
				file_list=$(find . -type f 2>/dev/null | sed 's|^\./||' || true)
			fi
		elif [ "${#positional_args[@]}" -gt 0 ]; then
			# No file set and no filters - use positional args as files to open directly
			# Convert array to newline-separated string for consistent handling
			file_list=$(printf '%s\n' "${positional_args[@]}")
		fi
		;;
esac

# Step 2: Apply all filename filters (cheap - do this before expensive grep)
# Both -n and positional arg are just filename pattern matching
if [ -n "$file_list" ]; then
	# Apply -n pattern if provided
	if [ -n "$name_pattern" ]; then
		file_list=$(echo "$file_list" | grep "$name_pattern" || true)
		if [ -z "$file_list" ]; then
			die "No files matching name pattern '$name_pattern'"
		fi
	fi

	# Apply positional filter if provided (only when using flags, not for direct file opening)
	if [ -n "$positional_filter" ] && { [ -n "$file_set" ] || [ -n "$grep_pattern" ] || [ -n "$name_pattern" ] || [ "$use_fzf" = true ]; }; then
		file_list=$(echo "$file_list" | grep "$positional_filter" || true)
		if [ -z "$file_list" ]; then
			die "No files matching filter '$positional_filter'"
		fi
	fi
fi

# Step 3: Apply content filter (expensive - do this last on the reduced file set)
if [ -n "$grep_pattern" ] && [ -n "$file_list" ]; then
	if [ "$is_git_repo" = true ]; then
		# Use git grep on the file list
		filtered=""
		while IFS= read -r file; do
			[ -z "$file" ] && continue
			if git grep -q "$grep_pattern" -- "$file" 2>/dev/null; then
				filtered="$filtered$file"$'\n'
			fi
		done <<< "$file_list"
		file_list="$filtered"
	else
		# Use regular grep
		filtered=""
		while IFS= read -r file; do
			[ -z "$file" ] && continue
			if [ -f "$file" ] && grep -q "$grep_pattern" "$file" 2>/dev/null; then
				filtered="$filtered$file"$'\n'
			fi
		done <<< "$file_list"
		file_list="$filtered"
	fi

	if [ -z "$file_list" ]; then
		die "No files matching content pattern '$grep_pattern'"
	fi
fi

# Use fzf for interactive selection if requested
if [ "$use_fzf" = true ]; then
	if ! command -v fzf >/dev/null 2>&1; then
		die "fzf is not installed"
	fi
	file_list=$(echo "$file_list" | fzf --multi)
	if [ -z "$file_list" ]; then
		echo "No files selected"
		exit 0
	fi
fi

# Open files in editor
editor="${EDITOR:-vi}"

# Convert file_list to proper arguments (handle spaces in filenames)
# Use tr + xargs -0 for cross-platform handling of newline-separated files
if [ -n "$file_list" ]; then
	echo "$file_list" | tr '\n' '\0' | xargs -0 $editor
else
	exec $editor
fi
